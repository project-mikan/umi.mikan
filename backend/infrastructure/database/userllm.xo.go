package database

// Code generated by xo. DO NOT EDIT.

import (
	"context"

	"github.com/google/uuid"
)

// UserLlm represents a row from 'public.user_llms'.
type UserLlm struct {
	UserID      uuid.UUID `json:"user_id"`      // user_id
	LlmProvider int16     `json:"llm_provider"` // llm_provider
	Token       string    `json:"token"`        // token
	CreatedAt   int64     `json:"created_at"`   // created_at
	UpdatedAt   int64     `json:"updated_at"`   // updated_at
	// xo fields
	_exists, _deleted bool
}

// Exists returns true when the [UserLlm] exists in the database.
func (ul *UserLlm) Exists() bool {
	return ul._exists
}

// Deleted returns true when the [UserLlm] has been marked for deletion
// from the database.
func (ul *UserLlm) Deleted() bool {
	return ul._deleted
}

// Insert inserts the [UserLlm] to the database.
func (ul *UserLlm) Insert(ctx context.Context, db DB) error {
	switch {
	case ul._exists: // already exists
		return logerror(&ErrInsertFailed{ErrAlreadyExists})
	case ul._deleted: // deleted
		return logerror(&ErrInsertFailed{ErrMarkedForDeletion})
	}
	// insert (manual)
	const sqlstr = `INSERT INTO public.user_llms (` +
		`user_id, llm_provider, token, created_at, updated_at` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5` +
		`)`
	// run
	logf(sqlstr, ul.UserID, ul.LlmProvider, ul.Token, ul.CreatedAt, ul.UpdatedAt)
	if _, err := db.ExecContext(ctx, sqlstr, ul.UserID, ul.LlmProvider, ul.Token, ul.CreatedAt, ul.UpdatedAt); err != nil {
		return logerror(err)
	}
	// set exists
	ul._exists = true
	return nil
}

// Update updates a [UserLlm] in the database.
func (ul *UserLlm) Update(ctx context.Context, db DB) error {
	switch {
	case !ul._exists: // doesn't exist
		return logerror(&ErrUpdateFailed{ErrDoesNotExist})
	case ul._deleted: // deleted
		return logerror(&ErrUpdateFailed{ErrMarkedForDeletion})
	}
	// update with composite primary key
	const sqlstr = `UPDATE public.user_llms SET ` +
		`llm_provider = $1, token = $2, created_at = $3, updated_at = $4 ` +
		`WHERE user_id = $5`
	// run
	logf(sqlstr, ul.LlmProvider, ul.Token, ul.CreatedAt, ul.UpdatedAt, ul.UserID)
	if _, err := db.ExecContext(ctx, sqlstr, ul.LlmProvider, ul.Token, ul.CreatedAt, ul.UpdatedAt, ul.UserID); err != nil {
		return logerror(err)
	}
	return nil
}

// Save saves the [UserLlm] to the database.
func (ul *UserLlm) Save(ctx context.Context, db DB) error {
	if ul.Exists() {
		return ul.Update(ctx, db)
	}
	return ul.Insert(ctx, db)
}

// Upsert performs an upsert for [UserLlm].
func (ul *UserLlm) Upsert(ctx context.Context, db DB) error {
	switch {
	case ul._deleted: // deleted
		return logerror(&ErrUpsertFailed{ErrMarkedForDeletion})
	}
	// upsert
	const sqlstr = `INSERT INTO public.user_llms (` +
		`user_id, llm_provider, token, created_at, updated_at` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5` +
		`)` +
		` ON CONFLICT (user_id) DO ` +
		`UPDATE SET ` +
		`llm_provider = EXCLUDED.llm_provider, token = EXCLUDED.token, created_at = EXCLUDED.created_at, updated_at = EXCLUDED.updated_at `
	// run
	logf(sqlstr, ul.UserID, ul.LlmProvider, ul.Token, ul.CreatedAt, ul.UpdatedAt)
	if _, err := db.ExecContext(ctx, sqlstr, ul.UserID, ul.LlmProvider, ul.Token, ul.CreatedAt, ul.UpdatedAt); err != nil {
		return logerror(err)
	}
	// set exists
	ul._exists = true
	return nil
}

// Delete deletes the [UserLlm] from the database.
func (ul *UserLlm) Delete(ctx context.Context, db DB) error {
	switch {
	case !ul._exists: // doesn't exist
		return nil
	case ul._deleted: // deleted
		return nil
	}
	// delete with single primary key
	const sqlstr = `DELETE FROM public.user_llms ` +
		`WHERE user_id = $1`
	// run
	logf(sqlstr, ul.UserID)
	if _, err := db.ExecContext(ctx, sqlstr, ul.UserID); err != nil {
		return logerror(err)
	}
	// set deleted
	ul._deleted = true
	return nil
}

// UserLlmByUserIDLlmProvider retrieves a row from 'public.user_llms' as a [UserLlm].
//
// Generated from index 'unique_user_llm'.
func UserLlmByUserIDLlmProvider(ctx context.Context, db DB, userID uuid.UUID, llmProvider int16) (*UserLlm, error) {
	// query
	const sqlstr = `SELECT ` +
		`user_id, llm_provider, token, created_at, updated_at ` +
		`FROM public.user_llms ` +
		`WHERE user_id = $1 AND llm_provider = $2`
	// run
	logf(sqlstr, userID, llmProvider)
	ul := UserLlm{
		_exists: true,
	}
	if err := db.QueryRowContext(ctx, sqlstr, userID, llmProvider).Scan(&ul.UserID, &ul.LlmProvider, &ul.Token, &ul.CreatedAt, &ul.UpdatedAt); err != nil {
		return nil, logerror(err)
	}
	return &ul, nil
}

// UserLlmByUserID retrieves a row from 'public.user_llms' as a [UserLlm].
//
// Generated from index 'user_llms_pkey'.
func UserLlmByUserID(ctx context.Context, db DB, userID uuid.UUID) (*UserLlm, error) {
	// query
	const sqlstr = `SELECT ` +
		`user_id, llm_provider, token, created_at, updated_at ` +
		`FROM public.user_llms ` +
		`WHERE user_id = $1`
	// run
	logf(sqlstr, userID)
	ul := UserLlm{
		_exists: true,
	}
	if err := db.QueryRowContext(ctx, sqlstr, userID).Scan(&ul.UserID, &ul.LlmProvider, &ul.Token, &ul.CreatedAt, &ul.UpdatedAt); err != nil {
		return nil, logerror(err)
	}
	return &ul, nil
}

// User returns the User associated with the [UserLlm]'s (UserID).
//
// Generated from foreign key 'user_llms_user_id_fkey'.
func (ul *UserLlm) User(ctx context.Context, db DB) (*User, error) {
	return UserByID(ctx, db, ul.UserID)
}
