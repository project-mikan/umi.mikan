package database

// Code generated by xo. DO NOT EDIT.

import (
	"context"

	"github.com/google/uuid"
)

// UserLlm represents a row from 'public.user_llms'.
type UserLlm struct {
	UserID                 uuid.UUID `json:"user_id"`                   // user_id
	LlmProvider            int16     `json:"llm_provider"`              // llm_provider
	Key                    string    `json:"key"`                       // key
	CreatedAt              int64     `json:"created_at"`                // created_at
	UpdatedAt              int64     `json:"updated_at"`                // updated_at
	AutoSummaryDaily       bool      `json:"auto_summary_daily"`        // auto_summary_daily
	AutoSummaryMonthly     bool      `json:"auto_summary_monthly"`      // auto_summary_monthly
	AutoLatestTrendEnabled bool      `json:"auto_latest_trend_enabled"` // auto_latest_trend_enabled
	// xo fields
	_exists, _deleted bool
}

// Exists returns true when the [UserLlm] exists in the database.
func (ul *UserLlm) Exists() bool {
	return ul._exists
}

// Deleted returns true when the [UserLlm] has been marked for deletion
// from the database.
func (ul *UserLlm) Deleted() bool {
	return ul._deleted
}

// Insert inserts the [UserLlm] to the database.
func (ul *UserLlm) Insert(ctx context.Context, db DB) error {
	switch {
	case ul._exists: // already exists
		return logerror(&ErrInsertFailed{ErrAlreadyExists})
	case ul._deleted: // deleted
		return logerror(&ErrInsertFailed{ErrMarkedForDeletion})
	}
	// insert (manual)
	const sqlstr = `INSERT INTO public.user_llms (` +
		`user_id, llm_provider, key, created_at, updated_at, auto_summary_daily, auto_summary_monthly, auto_latest_trend_enabled` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6, $7, $8` +
		`)`
	// run
	logf(sqlstr, ul.UserID, ul.LlmProvider, ul.Key, ul.CreatedAt, ul.UpdatedAt, ul.AutoSummaryDaily, ul.AutoSummaryMonthly, ul.AutoLatestTrendEnabled)
	if _, err := db.ExecContext(ctx, sqlstr, ul.UserID, ul.LlmProvider, ul.Key, ul.CreatedAt, ul.UpdatedAt, ul.AutoSummaryDaily, ul.AutoSummaryMonthly, ul.AutoLatestTrendEnabled); err != nil {
		return logerror(err)
	}
	// set exists
	ul._exists = true
	return nil
}

// Update updates a [UserLlm] in the database.
func (ul *UserLlm) Update(ctx context.Context, db DB) error {
	switch {
	case !ul._exists: // doesn't exist
		return logerror(&ErrUpdateFailed{ErrDoesNotExist})
	case ul._deleted: // deleted
		return logerror(&ErrUpdateFailed{ErrMarkedForDeletion})
	}
	// update with composite primary key
	const sqlstr = `UPDATE public.user_llms SET ` +
		`llm_provider = $1, key = $2, created_at = $3, updated_at = $4, auto_summary_daily = $5, auto_summary_monthly = $6, auto_latest_trend_enabled = $7 ` +
		`WHERE user_id = $8`
	// run
	logf(sqlstr, ul.LlmProvider, ul.Key, ul.CreatedAt, ul.UpdatedAt, ul.AutoSummaryDaily, ul.AutoSummaryMonthly, ul.AutoLatestTrendEnabled, ul.UserID)
	if _, err := db.ExecContext(ctx, sqlstr, ul.LlmProvider, ul.Key, ul.CreatedAt, ul.UpdatedAt, ul.AutoSummaryDaily, ul.AutoSummaryMonthly, ul.AutoLatestTrendEnabled, ul.UserID); err != nil {
		return logerror(err)
	}
	return nil
}

// Save saves the [UserLlm] to the database.
func (ul *UserLlm) Save(ctx context.Context, db DB) error {
	if ul.Exists() {
		return ul.Update(ctx, db)
	}
	return ul.Insert(ctx, db)
}

// Upsert performs an upsert for [UserLlm].
func (ul *UserLlm) Upsert(ctx context.Context, db DB) error {
	switch {
	case ul._deleted: // deleted
		return logerror(&ErrUpsertFailed{ErrMarkedForDeletion})
	}
	// upsert
	const sqlstr = `INSERT INTO public.user_llms (` +
		`user_id, llm_provider, key, created_at, updated_at, auto_summary_daily, auto_summary_monthly, auto_latest_trend_enabled` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6, $7, $8` +
		`)` +
		` ON CONFLICT (user_id) DO ` +
		`UPDATE SET ` +
		`llm_provider = EXCLUDED.llm_provider, key = EXCLUDED.key, created_at = EXCLUDED.created_at, updated_at = EXCLUDED.updated_at, auto_summary_daily = EXCLUDED.auto_summary_daily, auto_summary_monthly = EXCLUDED.auto_summary_monthly, auto_latest_trend_enabled = EXCLUDED.auto_latest_trend_enabled `
	// run
	logf(sqlstr, ul.UserID, ul.LlmProvider, ul.Key, ul.CreatedAt, ul.UpdatedAt, ul.AutoSummaryDaily, ul.AutoSummaryMonthly, ul.AutoLatestTrendEnabled)
	if _, err := db.ExecContext(ctx, sqlstr, ul.UserID, ul.LlmProvider, ul.Key, ul.CreatedAt, ul.UpdatedAt, ul.AutoSummaryDaily, ul.AutoSummaryMonthly, ul.AutoLatestTrendEnabled); err != nil {
		return logerror(err)
	}
	// set exists
	ul._exists = true
	return nil
}

// Delete deletes the [UserLlm] from the database.
func (ul *UserLlm) Delete(ctx context.Context, db DB) error {
	switch {
	case !ul._exists: // doesn't exist
		return nil
	case ul._deleted: // deleted
		return nil
	}
	// delete with single primary key
	const sqlstr = `DELETE FROM public.user_llms ` +
		`WHERE user_id = $1`
	// run
	logf(sqlstr, ul.UserID)
	if _, err := db.ExecContext(ctx, sqlstr, ul.UserID); err != nil {
		return logerror(err)
	}
	// set deleted
	ul._deleted = true
	return nil
}

// UserLlmByUserIDLlmProvider retrieves a row from 'public.user_llms' as a [UserLlm].
//
// Generated from index 'unique_user_llm'.
func UserLlmByUserIDLlmProvider(ctx context.Context, db DB, userID uuid.UUID, llmProvider int16) (*UserLlm, error) {
	// query
	const sqlstr = `SELECT ` +
		`user_id, llm_provider, key, created_at, updated_at, auto_summary_daily, auto_summary_monthly, auto_latest_trend_enabled ` +
		`FROM public.user_llms ` +
		`WHERE user_id = $1 AND llm_provider = $2`
	// run
	logf(sqlstr, userID, llmProvider)
	ul := UserLlm{
		_exists: true,
	}
	if err := db.QueryRowContext(ctx, sqlstr, userID, llmProvider).Scan(&ul.UserID, &ul.LlmProvider, &ul.Key, &ul.CreatedAt, &ul.UpdatedAt, &ul.AutoSummaryDaily, &ul.AutoSummaryMonthly, &ul.AutoLatestTrendEnabled); err != nil {
		return nil, logerror(err)
	}
	return &ul, nil
}

// UserLlmByUserID retrieves a row from 'public.user_llms' as a [UserLlm].
//
// Generated from index 'user_llms_pkey'.
func UserLlmByUserID(ctx context.Context, db DB, userID uuid.UUID) (*UserLlm, error) {
	// query
	const sqlstr = `SELECT ` +
		`user_id, llm_provider, key, created_at, updated_at, auto_summary_daily, auto_summary_monthly, auto_latest_trend_enabled ` +
		`FROM public.user_llms ` +
		`WHERE user_id = $1`
	// run
	logf(sqlstr, userID)
	ul := UserLlm{
		_exists: true,
	}
	if err := db.QueryRowContext(ctx, sqlstr, userID).Scan(&ul.UserID, &ul.LlmProvider, &ul.Key, &ul.CreatedAt, &ul.UpdatedAt, &ul.AutoSummaryDaily, &ul.AutoSummaryMonthly, &ul.AutoLatestTrendEnabled); err != nil {
		return nil, logerror(err)
	}
	return &ul, nil
}

// User returns the User associated with the [UserLlm]'s (UserID).
//
// Generated from foreign key 'user_llms_user_id_fkey'.
func (ul *UserLlm) User(ctx context.Context, db DB) (*User, error) {
	return UserByID(ctx, db, ul.UserID)
}
