package database

// Code generated by xo. DO NOT EDIT.

import (
	"context"

	"github.com/google/uuid"
)

// DiaryEntity represents a row from 'public.diary_entities'.
type DiaryEntity struct {
	ID        uuid.UUID `json:"id"`         // id
	DiaryID   uuid.UUID `json:"diary_id"`   // diary_id
	EntityID  uuid.UUID `json:"entity_id"`  // entity_id
	CreatedAt int64     `json:"created_at"` // created_at
	UpdatedAt int64     `json:"updated_at"` // updated_at
	Positions []byte    `json:"positions"`  // positions
	UsedText  string    `json:"used_text"`  // used_text
	// xo fields
	_exists, _deleted bool
}

// Exists returns true when the [DiaryEntity] exists in the database.
func (de *DiaryEntity) Exists() bool {
	return de._exists
}

// Deleted returns true when the [DiaryEntity] has been marked for deletion
// from the database.
func (de *DiaryEntity) Deleted() bool {
	return de._deleted
}

// Insert inserts the [DiaryEntity] to the database.
func (de *DiaryEntity) Insert(ctx context.Context, db DB) error {
	switch {
	case de._exists: // already exists
		return logerror(&ErrInsertFailed{ErrAlreadyExists})
	case de._deleted: // deleted
		return logerror(&ErrInsertFailed{ErrMarkedForDeletion})
	}
	// insert (manual)
	const sqlstr = `INSERT INTO public.diary_entities (` +
		`id, diary_id, entity_id, created_at, updated_at, positions, used_text` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6, $7` +
		`)`
	// run
	logf(sqlstr, de.ID, de.DiaryID, de.EntityID, de.CreatedAt, de.UpdatedAt, de.Positions, de.UsedText)
	if _, err := db.ExecContext(ctx, sqlstr, de.ID, de.DiaryID, de.EntityID, de.CreatedAt, de.UpdatedAt, de.Positions, de.UsedText); err != nil {
		return logerror(err)
	}
	// set exists
	de._exists = true
	return nil
}

// Update updates a [DiaryEntity] in the database.
func (de *DiaryEntity) Update(ctx context.Context, db DB) error {
	switch {
	case !de._exists: // doesn't exist
		return logerror(&ErrUpdateFailed{ErrDoesNotExist})
	case de._deleted: // deleted
		return logerror(&ErrUpdateFailed{ErrMarkedForDeletion})
	}
	// update with composite primary key
	const sqlstr = `UPDATE public.diary_entities SET ` +
		`diary_id = $1, entity_id = $2, created_at = $3, updated_at = $4, positions = $5, used_text = $6 ` +
		`WHERE id = $7`
	// run
	logf(sqlstr, de.DiaryID, de.EntityID, de.CreatedAt, de.UpdatedAt, de.Positions, de.UsedText, de.ID)
	if _, err := db.ExecContext(ctx, sqlstr, de.DiaryID, de.EntityID, de.CreatedAt, de.UpdatedAt, de.Positions, de.UsedText, de.ID); err != nil {
		return logerror(err)
	}
	return nil
}

// Save saves the [DiaryEntity] to the database.
func (de *DiaryEntity) Save(ctx context.Context, db DB) error {
	if de.Exists() {
		return de.Update(ctx, db)
	}
	return de.Insert(ctx, db)
}

// Upsert performs an upsert for [DiaryEntity].
func (de *DiaryEntity) Upsert(ctx context.Context, db DB) error {
	switch {
	case de._deleted: // deleted
		return logerror(&ErrUpsertFailed{ErrMarkedForDeletion})
	}
	// upsert
	const sqlstr = `INSERT INTO public.diary_entities (` +
		`id, diary_id, entity_id, created_at, updated_at, positions, used_text` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6, $7` +
		`)` +
		` ON CONFLICT (id) DO ` +
		`UPDATE SET ` +
		`diary_id = EXCLUDED.diary_id, entity_id = EXCLUDED.entity_id, created_at = EXCLUDED.created_at, updated_at = EXCLUDED.updated_at, positions = EXCLUDED.positions, used_text = EXCLUDED.used_text `
	// run
	logf(sqlstr, de.ID, de.DiaryID, de.EntityID, de.CreatedAt, de.UpdatedAt, de.Positions, de.UsedText)
	if _, err := db.ExecContext(ctx, sqlstr, de.ID, de.DiaryID, de.EntityID, de.CreatedAt, de.UpdatedAt, de.Positions, de.UsedText); err != nil {
		return logerror(err)
	}
	// set exists
	de._exists = true
	return nil
}

// Delete deletes the [DiaryEntity] from the database.
func (de *DiaryEntity) Delete(ctx context.Context, db DB) error {
	switch {
	case !de._exists: // doesn't exist
		return nil
	case de._deleted: // deleted
		return nil
	}
	// delete with single primary key
	const sqlstr = `DELETE FROM public.diary_entities ` +
		`WHERE id = $1`
	// run
	logf(sqlstr, de.ID)
	if _, err := db.ExecContext(ctx, sqlstr, de.ID); err != nil {
		return logerror(err)
	}
	// set deleted
	de._deleted = true
	return nil
}

// DiaryEntityByID retrieves a row from 'public.diary_entities' as a [DiaryEntity].
//
// Generated from index 'diary_entities_pkey'.
func DiaryEntityByID(ctx context.Context, db DB, id uuid.UUID) (*DiaryEntity, error) {
	// query
	const sqlstr = `SELECT ` +
		`id, diary_id, entity_id, created_at, updated_at, positions, used_text ` +
		`FROM public.diary_entities ` +
		`WHERE id = $1`
	// run
	logf(sqlstr, id)
	de := DiaryEntity{
		_exists: true,
	}
	if err := db.QueryRowContext(ctx, sqlstr, id).Scan(&de.ID, &de.DiaryID, &de.EntityID, &de.CreatedAt, &de.UpdatedAt, &de.Positions, &de.UsedText); err != nil {
		return nil, logerror(err)
	}
	return &de, nil
}

// DiaryEntitiesByDiaryID retrieves a row from 'public.diary_entities' as a [DiaryEntity].
//
// Generated from index 'index_diary_entities_diary_id'.
func DiaryEntitiesByDiaryID(ctx context.Context, db DB, diaryID uuid.UUID) ([]*DiaryEntity, error) {
	// query
	const sqlstr = `SELECT ` +
		`id, diary_id, entity_id, created_at, updated_at, positions, used_text ` +
		`FROM public.diary_entities ` +
		`WHERE diary_id = $1`
	// run
	logf(sqlstr, diaryID)
	rows, err := db.QueryContext(ctx, sqlstr, diaryID)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*DiaryEntity
	for rows.Next() {
		de := DiaryEntity{
			_exists: true,
		}
		// scan
		if err := rows.Scan(&de.ID, &de.DiaryID, &de.EntityID, &de.CreatedAt, &de.UpdatedAt, &de.Positions, &de.UsedText); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &de)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// DiaryEntitiesByEntityID retrieves a row from 'public.diary_entities' as a [DiaryEntity].
//
// Generated from index 'index_diary_entities_entity_id'.
func DiaryEntitiesByEntityID(ctx context.Context, db DB, entityID uuid.UUID) ([]*DiaryEntity, error) {
	// query
	const sqlstr = `SELECT ` +
		`id, diary_id, entity_id, created_at, updated_at, positions, used_text ` +
		`FROM public.diary_entities ` +
		`WHERE entity_id = $1`
	// run
	logf(sqlstr, entityID)
	rows, err := db.QueryContext(ctx, sqlstr, entityID)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*DiaryEntity
	for rows.Next() {
		de := DiaryEntity{
			_exists: true,
		}
		// scan
		if err := rows.Scan(&de.ID, &de.DiaryID, &de.EntityID, &de.CreatedAt, &de.UpdatedAt, &de.Positions, &de.UsedText); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &de)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// DiaryEntityByDiaryIDEntityID retrieves a row from 'public.diary_entities' as a [DiaryEntity].
//
// Generated from index 'unique_diary_entity'.
func DiaryEntityByDiaryIDEntityID(ctx context.Context, db DB, diaryID, entityID uuid.UUID) (*DiaryEntity, error) {
	// query
	const sqlstr = `SELECT ` +
		`id, diary_id, entity_id, created_at, updated_at, positions, used_text ` +
		`FROM public.diary_entities ` +
		`WHERE diary_id = $1 AND entity_id = $2`
	// run
	logf(sqlstr, diaryID, entityID)
	de := DiaryEntity{
		_exists: true,
	}
	if err := db.QueryRowContext(ctx, sqlstr, diaryID, entityID).Scan(&de.ID, &de.DiaryID, &de.EntityID, &de.CreatedAt, &de.UpdatedAt, &de.Positions, &de.UsedText); err != nil {
		return nil, logerror(err)
	}
	return &de, nil
}

// Diary returns the Diary associated with the [DiaryEntity]'s (DiaryID).
//
// Generated from foreign key 'diary_entities_diary_id_fkey'.
func (de *DiaryEntity) Diary(ctx context.Context, db DB) (*Diary, error) {
	return DiaryByID(ctx, db, de.DiaryID)
}

// Entity returns the Entity associated with the [DiaryEntity]'s (EntityID).
//
// Generated from foreign key 'diary_entities_entity_id_fkey'.
func (de *DiaryEntity) Entity(ctx context.Context, db DB) (*Entity, error) {
	return EntityByID(ctx, db, de.EntityID)
}
