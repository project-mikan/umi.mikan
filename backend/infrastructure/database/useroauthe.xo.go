package database

// Code generated by xo. DO NOT EDIT.

import (
	"context"

	"github.com/google/uuid"
)

// UserOauthe represents a row from 'public.user_oauthes'.
type UserOauthe struct {
	ID             uuid.UUID `json:"id"`               // id
	UserID         uuid.UUID `json:"user_id"`          // user_id
	ProviderName   string    `json:"provider_name"`    // provider_name
	ProviderUserID string    `json:"provider_user_id"` // provider_user_id
	AccessToken    string    `json:"access_token"`     // access_token
	RefreshToken   string    `json:"refresh_token"`    // refresh_token
	TokenExpiresAt int64     `json:"token_expires_at"` // token_expires_at
	CreatedAt      int64     `json:"created_at"`       // created_at
	UpdatedAt      int64     `json:"updated_at"`       // updated_at
	// xo fields
	_exists, _deleted bool
}

// Exists returns true when the [UserOauthe] exists in the database.
func (uo *UserOauthe) Exists() bool {
	return uo._exists
}

// Deleted returns true when the [UserOauthe] has been marked for deletion
// from the database.
func (uo *UserOauthe) Deleted() bool {
	return uo._deleted
}

// Insert inserts the [UserOauthe] to the database.
func (uo *UserOauthe) Insert(ctx context.Context, db DB) error {
	switch {
	case uo._exists: // already exists
		return logerror(&ErrInsertFailed{ErrAlreadyExists})
	case uo._deleted: // deleted
		return logerror(&ErrInsertFailed{ErrMarkedForDeletion})
	}
	// insert (manual)
	const sqlstr = `INSERT INTO public.user_oauthes (` +
		`id, user_id, provider_name, provider_user_id, access_token, refresh_token, token_expires_at, created_at, updated_at` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6, $7, $8, $9` +
		`)`
	// run
	logf(sqlstr, uo.ID, uo.UserID, uo.ProviderName, uo.ProviderUserID, uo.AccessToken, uo.RefreshToken, uo.TokenExpiresAt, uo.CreatedAt, uo.UpdatedAt)
	if _, err := db.ExecContext(ctx, sqlstr, uo.ID, uo.UserID, uo.ProviderName, uo.ProviderUserID, uo.AccessToken, uo.RefreshToken, uo.TokenExpiresAt, uo.CreatedAt, uo.UpdatedAt); err != nil {
		return logerror(err)
	}
	// set exists
	uo._exists = true
	return nil
}

// Update updates a [UserOauthe] in the database.
func (uo *UserOauthe) Update(ctx context.Context, db DB) error {
	switch {
	case !uo._exists: // doesn't exist
		return logerror(&ErrUpdateFailed{ErrDoesNotExist})
	case uo._deleted: // deleted
		return logerror(&ErrUpdateFailed{ErrMarkedForDeletion})
	}
	// update with composite primary key
	const sqlstr = `UPDATE public.user_oauthes SET ` +
		`user_id = $1, provider_name = $2, provider_user_id = $3, access_token = $4, refresh_token = $5, token_expires_at = $6, created_at = $7, updated_at = $8 ` +
		`WHERE id = $9`
	// run
	logf(sqlstr, uo.UserID, uo.ProviderName, uo.ProviderUserID, uo.AccessToken, uo.RefreshToken, uo.TokenExpiresAt, uo.CreatedAt, uo.UpdatedAt, uo.ID)
	if _, err := db.ExecContext(ctx, sqlstr, uo.UserID, uo.ProviderName, uo.ProviderUserID, uo.AccessToken, uo.RefreshToken, uo.TokenExpiresAt, uo.CreatedAt, uo.UpdatedAt, uo.ID); err != nil {
		return logerror(err)
	}
	return nil
}

// Save saves the [UserOauthe] to the database.
func (uo *UserOauthe) Save(ctx context.Context, db DB) error {
	if uo.Exists() {
		return uo.Update(ctx, db)
	}
	return uo.Insert(ctx, db)
}

// Upsert performs an upsert for [UserOauthe].
func (uo *UserOauthe) Upsert(ctx context.Context, db DB) error {
	switch {
	case uo._deleted: // deleted
		return logerror(&ErrUpsertFailed{ErrMarkedForDeletion})
	}
	// upsert
	const sqlstr = `INSERT INTO public.user_oauthes (` +
		`id, user_id, provider_name, provider_user_id, access_token, refresh_token, token_expires_at, created_at, updated_at` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6, $7, $8, $9` +
		`)` +
		` ON CONFLICT (id) DO ` +
		`UPDATE SET ` +
		`user_id = EXCLUDED.user_id, provider_name = EXCLUDED.provider_name, provider_user_id = EXCLUDED.provider_user_id, access_token = EXCLUDED.access_token, refresh_token = EXCLUDED.refresh_token, token_expires_at = EXCLUDED.token_expires_at, created_at = EXCLUDED.created_at, updated_at = EXCLUDED.updated_at `
	// run
	logf(sqlstr, uo.ID, uo.UserID, uo.ProviderName, uo.ProviderUserID, uo.AccessToken, uo.RefreshToken, uo.TokenExpiresAt, uo.CreatedAt, uo.UpdatedAt)
	if _, err := db.ExecContext(ctx, sqlstr, uo.ID, uo.UserID, uo.ProviderName, uo.ProviderUserID, uo.AccessToken, uo.RefreshToken, uo.TokenExpiresAt, uo.CreatedAt, uo.UpdatedAt); err != nil {
		return logerror(err)
	}
	// set exists
	uo._exists = true
	return nil
}

// Delete deletes the [UserOauthe] from the database.
func (uo *UserOauthe) Delete(ctx context.Context, db DB) error {
	switch {
	case !uo._exists: // doesn't exist
		return nil
	case uo._deleted: // deleted
		return nil
	}
	// delete with single primary key
	const sqlstr = `DELETE FROM public.user_oauthes ` +
		`WHERE id = $1`
	// run
	logf(sqlstr, uo.ID)
	if _, err := db.ExecContext(ctx, sqlstr, uo.ID); err != nil {
		return logerror(err)
	}
	// set deleted
	uo._deleted = true
	return nil
}

// UserOautheByID retrieves a row from 'public.user_oauthes' as a [UserOauthe].
//
// Generated from index 'user_oauthes_pkey'.
func UserOautheByID(ctx context.Context, db DB, id uuid.UUID) (*UserOauthe, error) {
	// query
	const sqlstr = `SELECT ` +
		`id, user_id, provider_name, provider_user_id, access_token, refresh_token, token_expires_at, created_at, updated_at ` +
		`FROM public.user_oauthes ` +
		`WHERE id = $1`
	// run
	logf(sqlstr, id)
	uo := UserOauthe{
		_exists: true,
	}
	if err := db.QueryRowContext(ctx, sqlstr, id).Scan(&uo.ID, &uo.UserID, &uo.ProviderName, &uo.ProviderUserID, &uo.AccessToken, &uo.RefreshToken, &uo.TokenExpiresAt, &uo.CreatedAt, &uo.UpdatedAt); err != nil {
		return nil, logerror(err)
	}
	return &uo, nil
}

// UserOautheByProviderNameProviderUserID retrieves a row from 'public.user_oauthes' as a [UserOauthe].
//
// Generated from index 'user_oauthes_provider_name_provider_user_id_key'.
func UserOautheByProviderNameProviderUserID(ctx context.Context, db DB, providerName, providerUserID string) (*UserOauthe, error) {
	// query
	const sqlstr = `SELECT ` +
		`id, user_id, provider_name, provider_user_id, access_token, refresh_token, token_expires_at, created_at, updated_at ` +
		`FROM public.user_oauthes ` +
		`WHERE provider_name = $1 AND provider_user_id = $2`
	// run
	logf(sqlstr, providerName, providerUserID)
	uo := UserOauthe{
		_exists: true,
	}
	if err := db.QueryRowContext(ctx, sqlstr, providerName, providerUserID).Scan(&uo.ID, &uo.UserID, &uo.ProviderName, &uo.ProviderUserID, &uo.AccessToken, &uo.RefreshToken, &uo.TokenExpiresAt, &uo.CreatedAt, &uo.UpdatedAt); err != nil {
		return nil, logerror(err)
	}
	return &uo, nil
}

// User returns the User associated with the [UserOauthe]'s (UserID).
//
// Generated from foreign key 'user_oauthes_user_id_fkey'.
func (uo *UserOauthe) User(ctx context.Context, db DB) (*User, error) {
	return UserByID(ctx, db, uo.UserID)
}
